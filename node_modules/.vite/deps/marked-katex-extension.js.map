{
  "version": 3,
  "sources": ["../../marked-katex-extension/src/index.js"],
  "sourcesContent": ["import katex from 'katex';\n\nconst inlineRule = /^(\\${1,2})(?!\\$)((?:\\\\.|[^\\\\\\n])*?(?:\\\\.|[^\\\\\\n\\$]))\\1(?=[\\s?!\\.,:？！。，：]|$)/;\nconst inlineRuleNonStandard = /^(\\${1,2})(?!\\$)((?:\\\\.|[^\\\\\\n])*?(?:\\\\.|[^\\\\\\n\\$]))\\1/; // Non-standard, even if there are no spaces before and after $ or $$, try to parse\n\nconst blockRule = /^(\\${1,2})\\n((?:\\\\[^]|[^\\\\])+?)\\n\\1(?:\\n|$)/;\n\nexport default function(options = {}) {\n  return {\n    extensions: [\n      inlineKatex(options, createRenderer(options, false)),\n      blockKatex(options, createRenderer(options, true)),\n    ],\n  };\n}\n\nfunction createRenderer(options, newlineAfter) {\n  return (token) => katex.renderToString(token.text, { ...options, displayMode: token.displayMode }) + (newlineAfter ? '\\n' : '');\n}\n\nfunction inlineKatex(options, renderer) {\n  const nonStandard = options && options.nonStandard;\n  const ruleReg = nonStandard ? inlineRuleNonStandard : inlineRule;\n  return {\n    name: 'inlineKatex',\n    level: 'inline',\n    start(src) {\n      let index;\n      let indexSrc = src;\n\n      while (indexSrc) {\n        index = indexSrc.indexOf('$');\n        if (index === -1) {\n          return;\n        }\n        const f = nonStandard ? index > -1 : index === 0 || indexSrc.charAt(index - 1) === ' ';\n        if (f) {\n          const possibleKatex = indexSrc.substring(index);\n\n          if (possibleKatex.match(ruleReg)) {\n            return index;\n          }\n        }\n\n        indexSrc = indexSrc.substring(index + 1).replace(/^\\$+/, '');\n      }\n    },\n    tokenizer(src, tokens) {\n      const match = src.match(ruleReg);\n      if (match) {\n        return {\n          type: 'inlineKatex',\n          raw: match[0],\n          text: match[2].trim(),\n          displayMode: match[1].length === 2,\n        };\n      }\n    },\n    renderer,\n  };\n}\n\nfunction blockKatex(options, renderer) {\n  return {\n    name: 'blockKatex',\n    level: 'block',\n    tokenizer(src, tokens) {\n      const match = src.match(blockRule);\n      if (match) {\n        return {\n          type: 'blockKatex',\n          raw: match[0],\n          text: match[2].trim(),\n          displayMode: match[1].length === 2,\n        };\n      }\n    },\n    renderer,\n  };\n}\n"],
  "mappings": ";;;;;;AAEA,IAAM,aAAa;AACnB,IAAM,wBAAwB;AAE9B,IAAM,YAAY;AAEH,SAAR,YAAiB,UAAU,CAAC,GAAG;AACpC,SAAO;AAAA,IACL,YAAY;AAAA,MACV,YAAY,SAAS,eAAe,SAAS,KAAK,CAAC;AAAA,MACnD,WAAW,SAAS,eAAe,SAAS,IAAI,CAAC;AAAA,IACnD;AAAA,EACF;AACF;AAEA,SAAS,eAAe,SAAS,cAAc;AAC7C,SAAO,CAAC,UAAU,MAAM,eAAe,MAAM,MAAM,EAAE,GAAG,SAAS,aAAa,MAAM,YAAY,CAAC,KAAK,eAAe,OAAO;AAC9H;AAEA,SAAS,YAAY,SAAS,UAAU;AACtC,QAAM,cAAc,WAAW,QAAQ;AACvC,QAAM,UAAU,cAAc,wBAAwB;AACtD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM,KAAK;AACT,UAAI;AACJ,UAAI,WAAW;AAEf,aAAO,UAAU;AACf,gBAAQ,SAAS,QAAQ,GAAG;AAC5B,YAAI,UAAU,IAAI;AAChB;AAAA,QACF;AACA,cAAM,IAAI,cAAc,QAAQ,KAAK,UAAU,KAAK,SAAS,OAAO,QAAQ,CAAC,MAAM;AACnF,YAAI,GAAG;AACL,gBAAM,gBAAgB,SAAS,UAAU,KAAK;AAE9C,cAAI,cAAc,MAAM,OAAO,GAAG;AAChC,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,mBAAW,SAAS,UAAU,QAAQ,CAAC,EAAE,QAAQ,QAAQ,EAAE;AAAA,MAC7D;AAAA,IACF;AAAA,IACA,UAAU,KAAK,QAAQ;AACrB,YAAM,QAAQ,IAAI,MAAM,OAAO;AAC/B,UAAI,OAAO;AACT,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK,MAAM,CAAC;AAAA,UACZ,MAAM,MAAM,CAAC,EAAE,KAAK;AAAA,UACpB,aAAa,MAAM,CAAC,EAAE,WAAW;AAAA,QACnC;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,WAAW,SAAS,UAAU;AACrC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,UAAU,KAAK,QAAQ;AACrB,YAAM,QAAQ,IAAI,MAAM,SAAS;AACjC,UAAI,OAAO;AACT,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK,MAAM,CAAC;AAAA,UACZ,MAAM,MAAM,CAAC,EAAE,KAAK;AAAA,UACpB,aAAa,MAAM,CAAC,EAAE,WAAW;AAAA,QACnC;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;",
  "names": []
}
